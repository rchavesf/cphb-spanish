\chapter{Introducción}

La programación competitiva combina dos temas:
(1) el diseño de algoritmos y (2) la implementación de algoritmos.

El \key{diseño de algoritmos} consiste en la resolución de problemas
y el pensamiento matemático.
Se necesitan habilidades para analizar problemas y resolverlos
de manera creativa.
Un algoritmo para resolver un problema
debe ser tanto correcto como eficiente,
y el núcleo del problema a menudo
trata de inventar un algoritmo eficiente.

El conocimiento teórico de los algoritmos
es importante para las personas que participan en la programación competitiva.
Típicamente, una solución a un problema es
una combinación de técnicas conocidas y
nuevos conocimientos.
Las técnicas que aparecen en la programación competitiva
también forman la base para la investigación científica
de los algoritmos.

La \key{implementación de algoritmos} requiere buenas
habilidades de programación.
En la programación competitiva, las soluciones
se califican mediante la prueba de un algoritmo implementado
usando un conjunto de casos de prueba.
Por lo tanto, no es suficiente que la idea del
algoritmo sea correcta, sino que la implementación también
debe ser correcta.

Un buen estilo de codificación en concursos es
directo y conciso.
Los programas deben escribirse rápidamente,
porque no hay mucho tiempo disponible.
A diferencia de la ingeniería de software tradicional,
los programas son cortos (generalmente como máximo unas
pocas cientos de líneas de código) y no necesitan
mantenimiento después del concurso.

\section{Lenguajes de programación}

\index{lenguaje de programación}

Actualmente, los lenguajes de programación más populares
utilizados en concursos son C++, Python y Java.
Por ejemplo, en Google Code Jam 2017,
entre los mejores 3,000 participantes,
el 79 \% utilizó C++,
el 16 \% utilizó Python y
el 8 \% utilizó Java \cite{goo17}.
Algunas personas participantes también utilizaron varios lenguajes.

Muchas personas piensan que C++ es la mejor opción
para una persona que participa en programación competitiva,
y C++ está casi siempre disponible en
sistemas de competencias.
Los beneficios de usar C++ son que
es un lenguaje muy eficiente y
su biblioteca estándar contiene una
gran colección
de estructuras de datos y algoritmos.

Por otro lado, es bueno
dominar varios lenguajes y comprender
sus fortalezas.
Por ejemplo, si se necesitan enteros grandes
en el problema,
Python puede ser una buena opción, porque
contiene operaciones integradas para
calcular con enteros grandes.
Aún así, la mayoría de los problemas en concursos de programación
están establecidos de tal manera que
usar un lenguaje de programación específico
no representa una ventaja injusta.

Todos los programas de ejemplo en este libro están escritos en C++,
y se utilizan a menudo las estructuras de datos y algoritmos
de la biblioteca estándar.
Los programas siguen el estándar C++11,
que se puede utilizar en la mayoría de los concursos en la actualidad.
Si aún no puedes programar en C++, 
ahora es un buen momento para comenzar a aprender.

\subsubsection{Plantilla de código C++}

Una plantilla típica de código C++ para programación competitiva
se ve así:

\begin{lstlisting}
#include <bits/stdc++.h>

using namespace std;

int main() {
    // aquí va la solución
}
\end{lstlisting}

La línea \texttt{\#include} al principio
del código es una característica del compilador \texttt{g++}
que nos permite incluir toda la biblioteca estándar.
Por lo tanto, no es necesario incluir por separado
bibliotecas como \texttt{iostream},
\texttt{vector} y \texttt{algorithm},
sino que están disponibles automáticamente.

La línea \texttt{using} declara
que las clases y funciones
de la biblioteca estándar se pueden utilizar directamente
en el código.
Sin la línea \texttt{using}, tendríamos
que escribir, por ejemplo, \texttt{std::cout},
pero ahora es suficiente con escribir \texttt{cout}.

El código se puede compilar utilizando el siguiente comando:

\begin{lstlisting}
g++ -std=c++11 -O2 -Wall test.cpp -o test
\end{lstlisting}

Este comando produce un archivo binario \texttt{test}
a partir del código fuente \texttt{test.cpp}.
El compilador sigue el estándar C++11
(\texttt{-std=c++11}),
optimiza el código (\texttt{-O2})
y muestra advertencias sobre posibles errores (\texttt{-Wall}).

\section{Entrada y salida}

\index{entrada y salida}

En la mayoría de los concursos, se utilizan flujos estándar
para leer la entrada y escribir la salida.
En C++, los flujos estándar son
\texttt{cin} para la entrada y \texttt{cout} para la salida.
Además, se pueden usar las funciones C
\texttt{scanf} y \texttt{printf}.

La entrada para el programa generalmente consiste en
números y cadenas que están separados por
espacios y saltos de línea.
Se pueden leer del flujo \texttt{cin}
de la siguiente manera:

\begin{lstlisting}
int a, b;
string x;
cin >> a >> b >> x;
\end{lstlisting}

Este tipo de código siempre funciona,
suponiendo que haya al menos un espacio
o salto de línea entre cada elemento en la entrada.
Por ejemplo, el código anterior puede leer
ambas entradas siguientes:
\begin{lstlisting}
123 456 mono
\end{lstlisting}
\begin{lstlisting}
123    456
mono
\end{lstlisting}
El flujo \texttt{cout} se utiliza para la salida
de la siguiente manera:
\begin{lstlisting}
int a = 123, b = 456;
string x = "mono";
cout << a << " " << b << " " << x << "\n";
\end{lstlisting}

La entrada y salida a veces
es un cuello de botella en el programa.
Las siguientes líneas al comienzo del código
hacen que la entrada y salida sean más eficientes:

\begin{lstlisting}
ios::sync_with_stdio(0);
cin.tie(0);
\end{lstlisting}

Tenga en cuenta que la línea nueva \texttt{"\textbackslash n"}
funciona más rápido que \texttt{endl},
porque \texttt{endl} siempre provoca
una operación de vaciado.

Las funciones C \texttt{scanf}
y \texttt{printf} son una alternativa
a los flujos estándar de C++.
Por lo general, son un poco más rápidas,
pero también son más difíciles de usar.
El siguiente código lee dos enteros de la entrada:
\begin{lstlisting}
int a, b;
scanf("%d %d", &a, &b);
\end{lstlisting}
El siguiente código imprime dos enteros:
\begin{lstlisting}
int a = 123, b = 456;
printf("%d %d\n", a, b);
\end{lstlisting}
A veces, el programa debe leer una línea completa
desde la entrada, posiblemente conteniendo espacios.
Esto se puede lograr utilizando la
función \texttt{getline}:

\begin{lstlisting}
string s;
getline(cin, s);
\end{lstlisting}

Si la cantidad de datos es desconocida, el siguiente
bucle es útil:
\begin{lstlisting}
while (cin >> x) {
    // código
}
\end{lstlisting}
Este bucle lee elementos de la entrada
uno tras otro, hasta que no haya
más datos disponibles en la entrada.

En algunos sistemas de competencia, se utilizan archivos para
entrada y salida.
Una solución fácil para esto es escribir
el código como de costumbre utilizando flujos estándar,
pero agregue las siguientes líneas al comienzo del código:
\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
\end{lstlisting}
Después de esto, el programa lee la entrada del archivo
''input.txt'' y escribe la salida en el archivo
''output.txt''.

\section{Trabajando con números}

\index{entero}

\subsubsection{Enteros}

El tipo de entero más utilizado en la programación competitiva
es \texttt{int}, que es un tipo de 32 bits con
un rango de valores de $-2^{31} \ldots 2^{31}-1$
o aproximadamente $-2 \cdot 10^9 \ldots 2 \cdot 10^9$.
Si el tipo \texttt{int} no es suficiente,
se puede utilizar el tipo de 64 bits \texttt{long long}.
Tiene un rango de valores de $-2^{63} \ldots 2^{63}-1$
o aproximadamente $-9 \cdot 10^{18} \ldots 9 \cdot 10^{18}$.

El siguiente código define una
variable \texttt{long long}:
\begin{lstlisting}
long long x = 123456789123456789LL;
\end{lstlisting}
El sufijo \texttt{LL} significa que el
tipo de número es \texttt{long long}.

Un error común al usar el tipo \texttt{long long}
es que el tipo \texttt{int} todavía se usa en alguna parte
en el código.
Por ejemplo, el siguiente código contiene
un error sutil:

\begin{lstlisting}
int a = 123456789;
long long b = a*a;
cout << b << "\n"; // -1757895751
\end{lstlisting}

Aunque la variable \texttt{b} es de tipo \texttt{long long},
ambos números en la expresión \texttt{a*a}
son de tipo \texttt{int} y el resultado es
también de tipo \texttt{int}.
Debido a esto, la variable \texttt{b} contendrá
un resultado incorrecto.
El problema se puede solucionar cambiando el tipo
de \texttt{a} a \texttt{long long} o
cambiando la expresión a \texttt{(long long)a*a}.


Por lo general, los problemas de concurso se establecen de tal manera que
el tipo \texttt{long long} es suficiente.
Aún así, es bueno saber que
el compilador \texttt{g++} también proporciona
un tipo de 128 bits \texttt{\_\_int128\_t}
con un rango de valores de
$-2^{127} \ldots 2^{127}-1$ o aproximadamente $-10^{38} \ldots 10^{38}$.
Sin embargo, este tipo no está disponible en todos los sistemas de concurso.

\subsubsection{Aritmética modular}

\index{residuo}
\index{aritmética modular}

Denotamos por $x \bmod m$ el residuo
cuando $x$ se divide por $m$.
Por ejemplo, $17 \bmod 5 = 2$,
porque $17 = 3 \cdot 5 + 2$.

A veces, la respuesta a un problema es un
número muy grande, pero es suficiente
darlo ''módulo $m$'', es decir,
el residuo cuando la respuesta se divide por $m$
(por ejemplo, ''módulo $10^9+7$'').
La idea es que incluso si la respuesta real
es muy grande,
basta con utilizar los tipos
\texttt{int} y \texttt{long long}.

Una propiedad importante del residuo es que
en suma, resta y multiplicación,
el residuo se puede tomar antes de la operación:

\[
\begin{array}{rcr}
(a+b) \bmod m & = & (a \bmod m + b \bmod m) \bmod m \\
(a-b) \bmod m & = & (a \bmod m - b \bmod m) \bmod m \\
(a \cdot b) \bmod m & = & (a \bmod m \cdot b \bmod m) \bmod m
\end{array}
\]

Así, podemos tomar el residuo después de cada operación
y los números nunca serán demasiado grandes.

Por ejemplo, el siguiente código calcula $n!$,
el factorial de $n$, módulo $m$:
\begin{lstlisting}
long long x = 1;
for (int i = 2; i <= n; i++) {
    x = (x*i)%m;
}
cout << x%m << "\n";
\end{lstlisting}

Por lo general, queremos que el residuo siempre
esté entre $0\ldots m-1$.
Sin embargo, en C++ y otros lenguajes,
el residuo de un número negativo
es cero o negativo.
Una forma fácil de asegurarse de que no haya
residuos negativos es calcular primero
el residuo como de costumbre y luego agregar $m$
si el resultado es negativo:
\begin{lstlisting}
x = x%m;
if (x < 0) x += m;
\end{lstlisting}
Sin embargo, esto solo es necesario cuando hay
restas en el código y el
residuo puede volverse negativo.

\subsubsection{Números de punto flotante}

\index{número de punto flotante}

Los tipos de punto flotante habituales en
programación competitiva son
el \texttt{double} de 64 bits
y, como una extensión en el compilador \texttt{g++},
el \texttt{long double} de 80 bits.
En la mayoría de los casos, \texttt{double} es suficiente,
pero \texttt{long double} es más preciso.

La precisión requerida de la respuesta
generalmente se proporciona en el enunciado del problema.
Una forma fácil de mostrar la respuesta es utilizar
la función \texttt{printf}
e indicar el número de decimales
en la cadena de formato.
Por ejemplo, el siguiente código imprime
el valor de $x$ con 9 decimales:

\begin{lstlisting}
printf("%.9f\n", x);
\end{lstlisting}

Una dificultad al usar números de punto flotante
es que algunos números no pueden ser representados
con precisión como números de punto flotante,
y habrá errores de redondeo.
Por ejemplo, el resultado del siguiente código
es sorprendente:

\begin{lstlisting}
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
\end{lstlisting}

Debido a un error de redondeo,
el valor de \texttt{x} es un poco menor que 1,
mientras que el valor correcto sería 1.

Es arriesgado comparar números de punto flotante
con el operador \texttt{==},
porque es posible que los valores deban ser
iguales pero no lo son debido a errores de precisión.
Una mejor manera de comparar números de punto flotante
es suponer que dos números son iguales
si la diferencia entre ellos es menor que $\varepsilon$,
donde $\varepsilon$ es un número pequeño.

En la práctica, los números se pueden comparar
de la siguiente manera ($\varepsilon=10^{-9}$):

\begin{lstlisting}
if (abs(a-b) < 1e-9) {
    // a y b son iguales
}
\end{lstlisting}

Tenga en cuenta que, aunque los números de punto flotante son inexactos,
los enteros hasta cierto límite aún pueden ser
representados con precisión.
Por ejemplo, utilizando \texttt{double},
es posible representar con precisión todos
los enteros cuyo valor absoluto sea como máximo $2^{53}$.

\section{Acortando código}

El código corto es ideal en programación competitiva,
porque los programas deben escribirse
lo más rápido posible.
Por ello, los programadores competitivos suelen definir
nombres más cortos para los tipos de datos y otras partes del código.

\subsubsection{Nombres de tipos}
\index{tuppdef@\texttt{typedef}}
Usando el comando \texttt{typedef}
es posible dar un nombre más corto
a un tipo de dato.
Por ejemplo, el nombre \texttt{long long} es largo,
así que podemos definir un nombre más corto \texttt{ll}:
\begin{lstlisting}
typedef long long ll;
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
long long a = 123456789;
long long b = 987654321;
cout << a*b << "\n";
\end{lstlisting}
puede acortarse de la siguiente manera:
\begin{lstlisting}
ll a = 123456789;
ll b = 987654321;
cout << a*b << "\n";
\end{lstlisting}

El comando \texttt{typedef}
también se puede utilizar con tipos más complejos.
Por ejemplo, el siguiente código proporciona
el nombre \texttt{vi} para un vector de enteros
y el nombre \texttt{pi} para un par
que contiene dos enteros.
\begin{lstlisting}
typedef vector<int> vi;
typedef pair<int,int> pi;
\end{lstlisting}

\subsubsection{Macros}
\index{macro}
Otra forma de acortar el código es definir
\key{macros}.
Un macro significa que ciertas cadenas en
el código se cambiarán antes de la compilación.
En C++, los macros se definen usando la
palabra clave \texttt{\#define}.

Por ejemplo, podemos definir los siguientes macros:
\begin{lstlisting}
#define F first
#define S second
#define PB push_back
#define MP make_pair
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
\end{lstlisting}
se puede acortar de la siguiente manera:
\begin{lstlisting}
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
\end{lstlisting}

Un macro también puede tener parámetros
lo que hace posible acortar bucles y otras
estructuras.
Por ejemplo, podemos definir el siguiente macro:
\begin{lstlisting}
#define REP(i,a,b) for (int i = a; i <= b; i++)
\end{lstlisting}
Después de esto, el código
\begin{lstlisting}
for (int i = 1; i <= n; i++) {
    search(i);
}
\end{lstlisting}
se puede acortar de la siguiente manera:
\begin{lstlisting}
REP(i,1,n) {
    search(i);
}
\end{lstlisting}

A veces los macros causan errores que pueden ser difíciles
de detectar. Por ejemplo, considere el siguiente macro
que calcula el cuadrado de un número:
\begin{lstlisting}
#define SQ(a) a*a
\end{lstlisting}
Este macro \emph{no} siempre funciona como se esperaba.
Por ejemplo, el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << 3+3*3+3 << "\n"; // 15
\end{lstlisting}

Una mejor versión del macro es la siguiente:
\begin{lstlisting}
#define SQ(a) (a)*(a)
\end{lstlisting}
Ahora el código
\begin{lstlisting}
cout << SQ(3+3) << "\n";
\end{lstlisting}
corresponde al código
\begin{lstlisting}
cout << (3+3)*(3+3) << "\n"; // 36
\end{lstlisting}

\section{Matemáticas}

Las matemáticas juegan un papel importante en la
programación competitiva, y no es posible convertirse
en una persona exitosa en programación competitiva sin
tener buenas habilidades matemáticas.
Esta sección trata algunos conceptos y fórmulas
matemáticas importantes que
serán necesarios más adelante en el libro.

\subsubsection{Fórmulas de suma}

Cada suma de la forma
\[\sum_{x=1}^n x^k = 1^k+2^k+3^k+\ldots+n^k,\]
donde $k$ es un número entero positivo,
tiene una fórmula cerrada que es un
polinomio de grado $k+1$.
Por ejemplo\footnote{\index{Fórmula de Faulhaber}
Existe incluso una fórmula general para tales sumas, llamada \key{Fórmula de Faulhaber},
pero es demasiado compleja para presentarla aquí.},
\[\sum_{x=1}^n x = 1+2+3+\ldots+n = \frac{n(n+1)}{2}\]
y
\[\sum_{x=1}^n x^2 = 1^2+2^2+3^2+\ldots+n^2 = \frac{n(n+1)(2n+1)}{6}.\]

Una \key{progresión aritmética} es una \index{progresión aritmética}
secuencia de números
donde la diferencia entre dos números consecutivos
es constante.
Por ejemplo,
\[3, 7, 11, 15\]
es una progresión aritmética con constante 4.
La suma de una progresión aritmética se puede calcular
usando la fórmula
\[\underbrace{a + \cdots + b}_{n \,\, \textrm{números}} = \frac{n(a+b)}{2}\]
donde $a$ es el primer número,
$b$ es el último número y
$n$ es la cantidad de números.
Por ejemplo,
\[3+7+11+15=\frac{4 \cdot (3+15)}{2} = 36.\]
La fórmula se basa en el hecho
de que la suma consiste en $n$ números y
el valor de cada número es $(a+b)/2$ en promedio.

\index{progresión geométrica}
Una \key{progresión geométrica} es una secuencia
de números
donde la proporción entre dos números consecutivos
es constante.
Por ejemplo,
\[3,6,12,24\]
es una progresión geométrica con constante 2.
La suma de una progresión geométrica se puede calcular
usando la fórmula
\[a + ak + ak^2 + \cdots + b = \frac{bk-a}{k-1}\]
donde $a$ es el primer número,
$b$ es el último número y la
proporción entre números consecutivos es $k$.
Por ejemplo,
\[3+6+12+24=\frac{24 \cdot 2 - 3}{2-1} = 45.\]


Esta fórmula se puede derivar de la siguiente manera. Sea
\[ S = a + ak + ak^2 + \cdots + b .\]
Al multiplicar ambos lados por $k$, obtenemos
\[ kS = ak + ak^2 + ak^3 + \cdots + bk,\]
y resolviendo la ecuación
\[ kS-S = bk-a\]
se obtiene la fórmula.

Un caso especial de una suma de una progresión geométrica es la fórmula
\[1+2+4+8+\ldots+2^{n-1}=2^n-1.\]

\index{suma armónica}

Una \key{suma armónica} es una suma de la forma
\[ \sum_{x=1}^n \frac{1}{x} = 1+\frac{1}{2}+\frac{1}{3}+\ldots+\frac{1}{n}.\]

Un límite superior para una suma armónica es $\log_2(n)+1$.
Es decir, podemos
modificar cada término $1/k$ de modo que $k$ se convierta
en la potencia de dos más cercana que no exceda $k$.
Por ejemplo, cuando $n=6$, podemos estimar
la suma de la siguiente manera:
\[ 1+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6} \le
1+\frac{1}{2}+\frac{1}{2}+\frac{1}{4}+\frac{1}{4}+\frac{1}{4}.\]
Este límite superior consta de $\log_2(n)+1$ partes
($1$, $2 \cdot 1/2$, $4 \cdot 1/4$, etc.),
y el valor de cada parte es como máximo 1.

\subsubsection{Teoría de conjuntos}

\index{teoría de conjuntos}
\index{conjunto}
\index{intersección}
\index{unión}
\index{diferencia}
\index{subconjunto}
\index{conjunto universal}
\index{complemento}

Un \key{conjunto} es una colección de elementos.
Por ejemplo, el conjunto
\[X=\{2,4,7\}\]
contiene los elementos 2, 4 y 7.
El símbolo $\emptyset$ denota un conjunto vacío,
y $|S|$ denota el tamaño de un conjunto $S$,
es decir, la cantidad de elementos en el conjunto.
Por ejemplo, en el conjunto anterior, $|X|=3$.

Si un conjunto $S$ contiene un elemento $x$,
escribimos $x \in S$,
y de lo contrario escribimos $x \notin S$.
Por ejemplo, en el conjunto anterior
\[4 \in X \hspace{10px}\textrm{y}\hspace{10px} 5 \notin X.\]

\begin{samepage}
Se pueden construir nuevos conjuntos utilizando operaciones de conjuntos:
\begin{itemize}
\item La \key{intersección} $A \cap B$ consiste en elementos
que están tanto en $A$ como en $B$.
Por ejemplo, si $A=\{1,2,5\}$ y $B=\{2,4\}$,
entonces $A \cap B = \{2\}$.
\item La \key{unión} $A \cup B$ consiste en elementos
que están en $A$ o en $B$ o en ambos.
Por ejemplo, si $A=\{3,7\}$ y $B=\{2,3,8\}$,
entonces $A \cup B = \{2,3,7,8\}$.
\item El \key{complemento} $\bar A$ consiste en elementos
que no están en $A$.
La interpretación de un complemento depende del
\key{conjunto universal}, que contiene todos los elementos posibles.
Por ejemplo, si $A=\{1,2,5,7\}$ y el conjunto universal es
$\{1,2,\ldots,10\}$, entonces $\bar A = \{3,4,6,8,9,10\}$.
\item La \key{diferencia} $A \setminus B = A \cap \bar B$
consiste en elementos que están en $A$ pero no en $B$.
Nótese que $B$ puede contener elementos que no están en $A$.
Por ejemplo, si $A=\{2,3,7,8\}$ y $B=\{3,5,8\}$,
entonces $A \setminus B = \{2,7\}$.
\end{itemize}
\end{samepage}

Si cada elemento de $A$ también pertenece a $S$,
decimos que $A$ es un \key{subconjunto} de $S$,
denotado por $A \subset S$.
Un conjunto $S$ siempre tiene $2^{|S|}$ subconjuntos,
incluido el conjunto vacío.
Por ejemplo, los subconjuntos del conjunto $\{2,4,7\}$ son
\begin{center}
$\emptyset$,
$\{2\}$, $\{4\}$, $\{7\}$, $\{2,4\}$, $\{2,7\}$, $\{4,7\}$ y $\{2,4,7\}$.
\end{center}

Algunos conjuntos utilizados con frecuencia son
$\mathbb{N}$ (números naturales),
$\mathbb{Z}$ (enteros),
$\mathbb{Q}$ (números racionales) y
$\mathbb{R}$ (números reales).
El conjunto $\mathbb{N}$
se puede definir de dos maneras, dependiendo
de la situación:
ya sea $\mathbb{N}=\{0,1,2,\ldots\}$
o $\mathbb{N}=\{1,2,3,\ldots\}$.

También podemos construir un conjunto usando una regla de la forma
\[\{f(n) : n \in S\},\]
donde $f(n)$ es alguna función.
Este conjunto contiene todos los elementos de la forma $f(n)$,
donde $n$ es un elemento en $S$.
Por ejemplo, el conjunto
\[X=\{2n : n \in \mathbb{Z}\}\]
contiene todos los números enteros pares.

\subsubsection{Lógica}

\index{logica}
\index{negación}
\index{conjunción}
\index{disyunción}
\index{implicación}
\index{equivalencia}

El valor de una expresión lógica es
\key{verdadero} (1) o \key{falso} (0).
Los operadores lógicos más importantes son
$\lnot$ (\key{negación}),
$\land$ (\key{conjunción}),
$\lor$ (\key{disyunción}),
$\Rightarrow$ (\key{implicación}) y
$\Leftrightarrow$ (\key{equivalencia}).
La siguiente tabla muestra los significados de estos operadores:

\begin{center}
\begin{tabular}{rr|rrrrrrr}
$A$ & $B$ & $\lnot A$ & $\lnot B$ & $A \land B$ & $A \lor B$ & $A \Rightarrow B$ & $A \Leftrightarrow B$ \\
\hline
0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 \\
1 & 1 & 0 & 0 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}

La expresión $\lnot A$ tiene el valor opuesto de $A$.
La expresión $A \land B$ es verdadera si tanto $A$ como $B$
son verdaderos,
y la expresión $A \lor B$ es verdadera si $A$ o $B$ o ambos
son verdaderos.
La expresión $A \Rightarrow B$ es verdadera
si siempre que $A$ es verdadero, también lo es $B$.
La expresión $A \Leftrightarrow B$ es verdadera
si $A$ y $B$ son ambos verdaderos o ambos falsos.

\index{predicado}

Un \key{predicado} es una expresión que es verdadera o falsa
dependiendo de sus parámetros.
Los predicados se denotan generalmente con letras mayúsculas.
Por ejemplo, podemos definir un predicado $P(x)$
que es verdadero exactamente cuando $x$ es un número primo.
Usando esta definición, $P(7)$ es verdadero pero $P(8)$ es falso.

\index{cuantificador}

Un \key{cuantificador} conecta una expresión lógica
con los elementos de un conjunto.
Los cuantificadores más importantes son
$\forall$ (\key{para todo}) y $\exists$ (\key{existe}).
Por ejemplo,
\[\forall x (\exists y (y < x))\]
significa que para cada elemento $x$ en el conjunto,
hay un elemento $y$ en el conjunto
tal que $y$ es menor que $x$.
Esto es cierto en el conjunto de los números enteros,
pero falso en el conjunto de los números naturales.

Usando la notación descrita anteriormente,
podemos expresar muchos tipos de proposiciones lógicas.
Por ejemplo,
\[\forall x ((x>1 \land \lnot P(x)) \Rightarrow (\exists a (\exists b (a > 1 \land b > 1 \land x = ab))))\]
significa que si un número $x$ es mayor que 1
y no es un número primo,
entonces hay números $a$ y $b$
que son mayores que $1$ y cuyo producto es $x$.
Esta proposición es verdadera en el conjunto de los enteros.

\subsubsection{Funciones}

La función $\lfloor x \rfloor$ redondea el número $x$
hacia abajo a un entero, y la función
$\lceil x \rceil$ redondea el número $x$
hacia arriba a un entero. Por ejemplo,
\[ \lfloor 3/2 \rfloor = 1 \hspace{10px} \textrm{y} \hspace{10px} \lceil 3/2 \rceil = 2.\]

Las funciones $\min(x_1,x_2,\ldots,x_n)$
y $\max(x_1,x_2,\ldots,x_n)$
dan el valor más pequeño y el más grande de los valores
$x_1,x_2,\ldots,x_n$.
Por ejemplo,
\[ \min(1,2,3)=1 \hspace{10px} \textrm{y} \hspace{10px} \max(1,2,3)=3.\]

\index{factorial}

El \key{factorial} $n!$ puede definirse
\[\prod_{x=1}^n x = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot n\]
o recursivamente
\[
\begin{array}{lcl}
0! & = & 1 \\
n! & = & n \cdot (n-1)! \\
\end{array}
\]

\index{número de Fibonacci}

Los \key{números de Fibonacci}
%\footnote{Fibonacci (c. 1175--1250) fue un matemático italiano.}
aparecen en muchas situaciones.
Se pueden definir recursivamente de la siguiente manera:
\[
\begin{array}{lcl}
f(0) & = & 0 \\
f(1) & = & 1 \\
f(n) & = & f(n-1)+f(n-2) \\
\end{array}
\]
Los primeros números de Fibonacci son
\[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, \ldots\]
También existe una fórmula de forma cerrada
para calcular los números de Fibonacci, que a veces se llama
\index{fórmula de Binet} \key{fórmula de Binet}:
\[f(n)=\frac{(1 + \sqrt{5})^n - (1-\sqrt{5})^n}{2^n \sqrt{5}}.\]

\subsubsection{Logaritmos}

\index{logaritmo}

El \key{logaritmo} de un número $x$
se denota como $\log_k(x)$, donde $k$ es la base
del logaritmo.
Según la definición,
$\log_k(x)=a$ exactamente cuando $k^a=x$.

Una propiedad útil de los logaritmos es
que $\log_k(x)$ es igual al número de veces
que tenemos que dividir $x$ por $k$ antes de llegar
al número 1.
Por ejemplo, $\log_2(32)=5$
porque se necesitan 5 divisiones por 2:

\[32 \rightarrow 16 \rightarrow 8 \rightarrow 4 \rightarrow 2 \rightarrow 1 \]

Los logaritmos se utilizan a menudo en el análisis de
algoritmos, porque muchos algoritmos eficientes
dividen algo a la mitad en cada paso.
Por lo tanto, podemos estimar la eficiencia de tales algoritmos
usando logaritmos.

El logaritmo de un producto es
\[\log_k(ab) = \log_k(a)+\log_k(b),\]
y en consecuencia,
\[\log_k(x^n) = n \cdot \log_k(x).\]
Además, el logaritmo de un cociente es
\[\log_k\Big(\frac{a}{b}\Big) = \log_k(a)-\log_k(b).\]
Otra fórmula útil es
\[\log_u(x) = \frac{\log_k(x)}{\log_k(u)},\]
y usando esto, es posible calcular
logaritmos en cualquier base si hay una forma de
calcular logaritmos en alguna base fija.

\index{logaritmo natural}

El \key{logaritmo natural} $\ln(x)$ de un número $x$
es un logaritmo cuya base es $e \approx 2.71828$.
Otra propiedad de los logaritmos es que
el número de dígitos de un entero $x$ en base $b$ es
$\lfloor \log_b(x)+1 \rfloor$.
Por ejemplo, la representación de
$123$ en base $2$ es 1111011 y
$\lfloor \log_2(123)+1 \rfloor = 7$.

\section{Concursos y recursos}

\subsubsection{IOI}

La Olimpiada Internacional de Informática (IOI, por sus siglas en inglés)
es un concurso anual de programación para
estudiantes de secundaria.
Cada país puede enviar un equipo de
cuatro estudiantes al concurso.
Suele haber unos 300 participantes
de 80 países.

La IOI consta de dos concursos de cinco horas de duración.
En ambos concursos, se pide a los participantes que
resuelvan tres tareas de algoritmos de dificultad variable.
Las tareas se dividen en subtareas,
cada una de las cuales tiene una puntuación asignada.
Aunque los concursantes se dividen en equipos,
compiten como individuos.

El temario de la IOI \cite{iois} regula los temas
que pueden aparecer en las tareas de la IOI.
Casi todos los temas del temario de la IOI
están cubiertos por este libro.

Los participantes para la IOI se seleccionan a través de
concursos nacionales.
Antes de la IOI, se organizan muchos concursos regionales,
como la Olimpiada Báltica de Informática (BOI),
la Olimpiada Centro Europea de Informática (CEOI)
y la Olimpiada de Informática Asia-Pacífico (APIO).

Algunos países organizan concursos de práctica en línea
para futuros participantes de la IOI,
como la Competencia Abierta Croata de Informática \cite{coci}
y la Olimpiada de Computación de EE. UU. \cite{usaco}.
Además, hay una gran colección de problemas de concursos polacos
disponibles en línea \cite{main}.

\subsubsection{ICPC}

El Concurso Internacional de Programación Universitaria (ICPC)
es un concurso anual de programación para estudiantes universitarios.
Cada equipo en el concurso está compuesto por tres estudiantes,
y a diferencia de la IOI, los estudiantes trabajan juntos;
solo hay una computadora disponible para cada equipo.

El ICPC consta de varias etapas y, finalmente, los
mejores equipos son invitados a la Final Mundial.
Aunque hay decenas de miles de participantes
en el concurso, solo hay una pequeña cantidad\footnote{El número exacto de plazas finales varía
de un año a otro; en 2017, había 133 plazas finales.} de plazas finales disponibles,
por lo que incluso avanzar a las finales
es un gran logro en algunas regiones.

En cada concurso del ICPC, los equipos tienen cinco horas para
resolver alrededor de diez problemas de algoritmos.
Una solución a un problema es aceptada solo si resuelve
todos los casos de prueba de manera eficiente.
Durante el concurso, los competidores pueden ver los resultados de otros equipos,
pero durante la última hora, el marcador se congela y no
es posible ver los resultados de las últimas entregas.

Los temas que pueden aparecer en el ICPC no están tan bien
especificados como los de la IOI.
En cualquier caso, está claro que se necesita más conocimiento
en el ICPC, especialmente habilidades matemáticas adicionales.

\subsubsection{Concursos en línea}

También hay muchos concursos en línea abiertos para todos.
Actualmente, el sitio de concursos más activo es Codeforces,
que organiza concursos aproximadamente cada semana.
En Codeforces, los participantes se dividen en dos divisiones:
los principiantes compiten en Div2 y los programadores más experimentados en Div1.
Otros sitios de concursos incluyen AtCoder, CS Academy, HackerRank y Topcoder.

Algunas empresas organizan concursos en línea con finales presenciales.
Ejemplos de tales concursos son Facebook Hacker Cup,
Google Code Jam y Yandex.Algorithm.
Por supuesto, las empresas también utilizan esos concursos para contratar:
tener un buen desempeño en un concurso es una buena manera de demostrar habilidades.

\subsubsection{Libros}

Ya hay algunos libros (además de este libro) que
se enfocan en la programación competitiva y la resolución de problemas algorítmicos:

\begin{itemize}
\item S. S. Skiena and M. A. Revilla:
\emph{Programming Challenges: The Programming Contest Training Manual} \cite{ski03}
\item S. Halim and F. Halim:
\emph{Competitive Programming 3: The New Lower Bound of Programming Contests} \cite{hal13}
\item K. Diks et al.: \emph{Looking for a Challenge? The Ultimate Problem Set from
the University of Warsaw Programming Competitions} \cite{dik12}
\end{itemize}

Los primeros dos libros están destinados a principiantes,
mientras que el último libro contiene material avanzado.

Por supuesto, los libros de algoritmos generales también son adecuados para
programadores competitivos.
Algunos libros populares son:

\begin{itemize}
\item T. H. Cormen, C. E. Leiserson, R. L. Rivest and C. Stein:
\emph{Introduction to Algorithms} \cite{cor09}
\item J. Kleinberg and É. Tardos:
\emph{Algorithm Design} \cite{kle05}
\item S. S. Skiena:
\emph{The Algorithm Design Manual} \cite{ski08}
\end{itemize}
